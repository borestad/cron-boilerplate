#!/usr/bin/env bash
set -euo pipefail

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Preinstall
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
function exists() { command -v $1 &> /dev/null; }

download() {
  local url="$1"
  local software=$(basename "$url")
  local location=~/.local/bin/$software

  echo "✔ [Download]: $software into $location"
  wget -O $location -q -nv --content-disposition "$url"
  chmod +x $location 2> /dev/null || true
}

install-deb() {
  local pkgs="$@"
  local exitcode=0

  echo "✔ [install-deb]: $pkgs"
  sudo eatmydata -- apt-get clean
  sudo eatmydata -- dpkg --clear-avail

  sudo eatmydata -- apt-fast -qq install --download-only -y $pkgs || exitcode=$?

  if [ ! $exitcode -eq 0 ]; then
    echo "[install-deb]: ❌ Error downloading $pkgs"
    echo "[install-deb]: (1/2) Retrying with apt-fast update: $pkgs"
    sudo eatmydata -- apt-fast update

    echo "[install-deb]: (2/2) Retrying with apt-fast --download-only: $pkgs"
    sudo eatmydata -- apt-fast -qq install --download-only -y $pkgs || exit 1
  fi

  echo "✔ [install-deb]: Extracting *.deb: $pkgs"
  ( cd /var/cache/apt && sudo find . -iname '*.deb' -print0 | xargs -I {} -0 sudo -- eatmydata dpkg --force-unsafe-io -x "{}" / )
}

preinstall-binaries() {
  local dir=$PWD

  # Testing:
  # sudo rm -rf /var/lib/apt/archives/*
  # sudo rm -rf /var/cache/*

  # Optimize apt install time (no need for mandb on a ci)
  sudo cp -p /bin/true /usr/bin/mandb 2> /dev/null || true
  sudo mv -fv /var/cache/man /var/cache/man.bak 2> /dev/null || true
  sudo mv -fv /usr/share/locale /usr/share/locale.bak
  sudo mv -fv /usr/share/man /usr/share/man.bak
  sudo mv -fv /usr/share/doc /usr/share/doc.bak

  sudo rm -rfv /etc/apt/apt.conf.d/*needrestart*

  # TODO: Needs some testing. But no need for hooks, since it's a shortlived CI process.
  sudo rm -rfv /etc/apt/apt.conf.d/*
  cp .github/scripts/ciutil ~/.local/bin/

  # Install apt packages if available
  pkgs=$(jq .dpkgInstallPackages[] package.json 2> /dev/null | xargs)

  if [[ "$pkgs" != "" ]]; then
    install-deb $pkgs &
  fi

  for url in $(jq .preinstallBinaries package.json | jq -r .[]); do
    download "$url" &
  done

  wait

  cd $dir
}

install-nodemodules() {
  if jq -e .dependencies `git rev-parse --show-toplevel`/package.json &> /dev/null; then
    cd $GITROOT

    # Applying dirty fix for *not* including @types/* in the production ci
    if [ -f pnpm-lock.yaml ]; then
      cp pnpm-lock.yaml $RUNNER_TEMPDIR/
      grep -v "'@types/" $RUNNER_TEMPDIR/pnpm-lock.yaml >| pnpm-lock.yaml
    fi

    pnpm install --frozen-lockfile --production --prefer-offline --no-verify-store-integrity

    mv $RUNNER_TEMPDIR/pnpm-lock.yaml .
  else
    echo "Nothing to install"
  fi
}

to_env() {
  [[ "$2" == *"/"* ]] && (echo "$1 => $2" && mkdir -p $2 || true 2> /dev/null)
  export $1=$2
  echo "$1=$2" >> $GITHUB_ENV
}

add_path() {
  echo $1 >> $GITHUB_PATH
}

set-env-variables() {
  mkdir -pv ~/.local/bin

  # Action Cache
  WS=$RUNNER_WORKSPACE

  # to_env LD_PRELOAD /usr/lib/x86_64-linux-gnu/libeatmydata.so
  to_env ACTIONS_CACHE_DIR $WS/.actions-cache
  to_env ACTIONS_CACHE_BIN_DIR $WS/.actions-cache/bin
  to_env PNPM_STORE_DIR $WS/.actions-cache/pnpm/pnpm-store
  to_env EGET_BIN $WS/.actions-cache/bin
  to_env DENO_DIR $WS/.actions-cache/.deno
  to_env PNPM_HOME $WS/.actions-cache/pnpm

  # TTL Cache (Cache that will automatically be invalidated)
  to_env TTL_CACHE_DIR $WS/.cache-ttl
  to_env BKT_CACHE_DIR $WS/.cache-ttl/bkt

  # Files Cache (Cache that will automatically be invalidated)
  to_env FILES_CACHE_DIR $WS/.cache-files

  # Other dirs
  to_env DEBUG_DIR $WS/.debug
  to_env RUNNER_TEMPDIR $RUNNER_TEMP/$(date +%s%N)

  # Other env
  to_env CACHE_PREFIX_WEEKLY "$(date +'%U')"      # changes every week (i.e 06)
  to_env CACHE_PREFIX_DAILY "$(date +'%Y-%m-%d')" # changes every day (i.e 2024-02-12)
  date +'%U'
  to_env NODE_ENV production
  to_env TERM xterm-256color
  to_env FORCE_COLOR 1

  # PATH
  add_path './node_modules/.bin'
  add_path $HOME/.local/bin
  add_path $WS/.actions-cache/pnpm
  add_path $WS/.actions-cache/bin
  add_path $GITHUB_WORKSPACE/.cron/scripts
}


# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Debug / Statistics / Information
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
show-cache-structure-default() { dust -b -P -s -r $ACTIONS_CACHE_DIR && echo; }
show-cache-structure-files() { dust -b -P -s -r $FILES_CACHE_DIR && echo; }
show-cache-structure-ttl() { dust -b -P -s -r $TTL_CACHE_DIR && echo; }

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Formatters / Printers
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✨() { ___; echo "✨ $1"; echo; }

___() { echo; printf '━%.0s' {1..80}; echo; }

# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
# Git Utils
# ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
has-file-changed() {
  changed_files="$(git diff-tree -r --name-only --no-commit-id ORIG_HEAD HEAD 2> /dev/null)"
  if $(echo "$changed_files" | grep --quiet "$1"); then
    return 0
  fi
  return 1
}

git-commit-to-repository() {
  DATE=$(date '+%Y/%m/%d %H:%M')
  LABEL="CRON"

  echo
  git diff --stat HEAD
  echo

  git config user.name github-actions
  git config user.email github-actions@github.com
  git pull --rebase --autostash

  for file in $(git status -s | cut -c4-); do
    echo "file: $file";
    shortname=$(basename $file)
    git add $file
    stats=$(git diff --cached --shortstat | sed -E 's/ (insertions?|deletions?|changed?)//g' | sed 's/,//g' | xargs)
    stats=$(echo $stats | sed 's/1 file//g' | xargs)
    git commit -m "\`️️⚡️ $LABEL ⚡️\` \`$DATE\` \`$stats $shortname\`" || true
    echo $stats
  done

  git push
}


# Allow calling for methods from outside
for i in "$@"; do
  "$i"
done
